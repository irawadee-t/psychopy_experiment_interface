#!/usr/bin/env python

# --- Import packages ---
from psychopy import locale_setup
from psychopy import prefs
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors, layout
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

from psychopy.hardware import keyboard

from pylsl import StreamInfo, StreamOutlet

info = StreamInfo(name='example_stream', type='Markers', channel_count=1,
                  channel_format='int32', source_id='example_stream_001')
outlet = StreamOutlet(info)  # Broadcast the stream.

# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)
# Store info about the experiment session
psychopyVersion = '2022.2.2'
expName = 'test_exp'  # from the Builder filename that created this script
expInfo = {
    'participant': f"{randint(0, 999999):06.0f}",
    'session': '001',
}
# --- Show participant info dialog --
dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
expInfo['psychopyVersion'] = psychopyVersion

# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + \
    u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
                                 extraInfo=expInfo, runtimeInfo=None,
                                 originPath='/Users/irawadee.t/Desktop/test_psychopy/prelim_andrew.py',
                                 savePickle=True, saveWideText=True,
                                 dataFileName=filename)
# save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.EXP)
# this outputs to the screen, not a file
logging.console.setLevel(logging.WARNING)

endExpNow = False  # flag for 'escape' or other condition => quit the exp
frameTolerance = 0.001  # how close to onset before 'same' frame

# Start Code - component code to be run after the window creation

# Event Markers

markers = {
    'start_rest1': [1],
    'start_drink1': [2],
    'stop_drink1': [3],
    'start_drink2': [4],
    'stop_drink2': [5],
    'start_rest2': [6],
    'end_exp': [7],
    'test': [99],
}

# Send triggers to test communication.
for _ in range(5):
    outlet.push_sample(markers['test'])
    core.wait(0.5)

# --- Setup the Window ---
win = visual.Window(
    size=[1344, 840], fullscr=True, screen=0,
    winType='pyglet', allowStencil=False,
    monitor='testMonitor', color=[0, 0, 0], colorSpace='rgb',
    blendMode='avg', useFBO=True,
    units='height')
win.mouseVisible = False
# store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None:
    frameDur = 1.0 / round(expInfo['frameRate'])
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess
# --- Setup input devices ---
ioConfig = {}
ioSession = ioServer = eyetracker = None

# create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard(backend='ptb')

# --- Initialize components for Routine "WelcomeMessage" ---
Welcome = visual.TextStim(win=win, name='Welcome',
                          text='Welcome to the experiment. The experiment will begin in the next slide. \n\nIn the next slide, STARE at the black dot.\n\nWhen ready, press SPACEBAR.',
                          font='Open Sans',
                          pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0,
                          color='white', colorSpace='rgb', opacity=None,
                          languageStyle='LTR',
                          depth=0.0)
start_key = keyboard.Keyboard()

# --- Initialize components for Routine "rest_1" ---
center_dot = visual.ShapeStim(
    win=win, name='center_dot',
    size=(0.05, 0.05), vertices='circle',
    ori=0.0, pos=(0, 0), anchor='center',
    lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, -1.0000, -1.0000], fillColor=[-1.0000, -1.0000, -1.0000],
    opacity=None, depth=0.0, interpolate=True)

# --- Initialize components for Routine "beforeStart" ---
prep = visual.TextStim(win=win, name='prep',
                       text='In the next slide, drink until satiety (MAX 5 mins)\n\npress SPACE when ready to start drinking water',
                       font='Open Sans',
                       pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0,
                       color='white', colorSpace='rgb', opacity=None,
                       languageStyle='LTR',
                       depth=0.0)
start_drink1 = keyboard.Keyboard()

# --- Initialize components for Routine "drink1" ---
drink1_5mins = visual.TextStim(win=win, name='drink1_5mins',
                               text='drink until satiety (MAX 5 mins)\n\npress SPACE when done',
                               font='Open Sans',
                               pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0,
                               color='white', colorSpace='rgb', opacity=None,
                               languageStyle='LTR',
                               depth=0.0)
stop_drink1 = keyboard.Keyboard()

# --- Initialize components for Routine "betweenTask" ---
break_between = visual.TextStim(win=win, name='break_between',
                                text='In the next slide, drink until stomach is completely full (MAX 5 mins).\n\npress SPACE when ready for drink2',
                                font='Open Sans',
                                pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0,
                                color='white', colorSpace='rgb', opacity=None,
                                languageStyle='LTR',
                                depth=0.0)
start_drink2 = keyboard.Keyboard()

# --- Initialize components for Routine "drink2" ---
drink2_5mins = visual.TextStim(win=win, name='drink2_5mins',
                               text='Drink until stomach is completely full (MAX 5 mins)\n\npress SPACE when done',
                               font='Open Sans',
                               pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0,
                               color='white', colorSpace='rgb', opacity=None,
                               languageStyle='LTR',
                               depth=0.0)
stop_drink2 = keyboard.Keyboard()

# --- Initialize components for Routine "afterTrial" ---
before_rest = visual.TextStim(win=win, name='before_rest',
                              text='Now get ready for 60 mins of resting state. \n\nStare at the black dot in the next slide.\n\npress SPACE when ready to do resting state',
                              font='Open Sans',
                              pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0,
                              color='white', colorSpace='rgb', opacity=None,
                              languageStyle='LTR',
                              depth=0.0)
rest_start = keyboard.Keyboard()

# --- Initialize components for Routine "rest_2" ---
dot = visual.ShapeStim(
    win=win, name='dot',
    size=(0.05, 0.05), vertices='circle',
    ori=0.0, pos=(0, 0), anchor='center',
    lineWidth=1.0,     colorSpace='rgb',  lineColor=[-1.0000, -1.0000, -1.0000], fillColor=[-1.0000, -1.0000, -1.0000],
    opacity=None, depth=0.0, interpolate=True)

# --- Initialize components for Routine "EndMessage" ---
end_message = visual.TextStim(win=win, name='end_message',
                              text='Thank you for participating in the experiment. Press SPACE to end.',
                              font='Open Sans',
                              pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0,
                              color='white', colorSpace='rgb', opacity=None,
                              languageStyle='LTR',
                              depth=0.0)
end_exp = keyboard.Keyboard()

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
# to track time remaining of each (possibly non-slip) routine
routineTimer = core.Clock()

# --- Prepare to start Routine "WelcomeMessage" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
start_key.keys = []
start_key.rt = []
_start_key_allKeys = []
# keep track of which components have finished
WelcomeMessageComponents = [Welcome, start_key]
for thisComponent in WelcomeMessageComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "WelcomeMessage" ---
while continueRoutine:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *Welcome* updates
    if Welcome.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        Welcome.frameNStart = frameN  # exact frame index
        Welcome.tStart = t  # local t and not account for scr refresh
        Welcome.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(Welcome, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'Welcome.started')
        Welcome.setAutoDraw(True)

    # *start_key* updates
    waitOnFlip = False
    if start_key.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        start_key.frameNStart = frameN  # exact frame index
        start_key.tStart = t  # local t and not account for scr refresh
        start_key.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(start_key, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'start_key.started')
        start_key.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(start_key.clock.reset)  # t=0 on next screen flip
        # clear events on next screen flip
        win.callOnFlip(start_key.clearEvents, eventType='keyboard')
    if start_key.status == STARTED and not waitOnFlip:
        theseKeys = start_key.getKeys(keyList=['space'], waitRelease=False)
        _start_key_allKeys.extend(theseKeys)
        if len(_start_key_allKeys):
            # just the last key pressed
            start_key.keys = _start_key_allKeys[-1].name
            start_key.rt = _start_key_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        outlet.push_sample(markers['start_rest1'])
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in WelcomeMessageComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "WelcomeMessage" ---
for thisComponent in WelcomeMessageComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if start_key.keys in ['', [], None]:  # No response was made
    start_key.keys = None
thisExp.addData('start_key.keys', start_key.keys)
if start_key.keys != None:  # we had a response
    thisExp.addData('start_key.rt', start_key.rt)
thisExp.nextEntry()
# the Routine "WelcomeMessage" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# --- Prepare to start Routine "rest_1" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
# keep track of which components have finished
rest_1Components = [center_dot]
for thisComponent in rest_1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "rest_1" ---
while continueRoutine and routineTimer.getTime() < 720.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *center_dot* updates
    if center_dot.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        center_dot.frameNStart = frameN  # exact frame index
        center_dot.tStart = t  # local t and not account for scr refresh
        center_dot.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(center_dot, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'center_dot.started')
        center_dot.setAutoDraw(True)
    if center_dot.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > center_dot.tStartRefresh + 720-frameTolerance:
            # keep track of stop time/frame for later
            center_dot.tStop = t  # not accounting for scr refresh
            center_dot.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'center_dot.stopped')
            center_dot.setAutoDraw(False)

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in rest_1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "rest_1" ---
for thisComponent in rest_1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-720.000000)

# --- Prepare to start Routine "beforeStart" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
start_drink1.keys = []
start_drink1.rt = []
_start_drink1_allKeys = []
# keep track of which components have finished
beforeStartComponents = [prep, start_drink1]
for thisComponent in beforeStartComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "beforeStart" ---
while continueRoutine:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *prep* updates
    if prep.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        prep.frameNStart = frameN  # exact frame index
        prep.tStart = t  # local t and not account for scr refresh
        prep.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(prep, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'prep.started')
        prep.setAutoDraw(True)

    # *start_drink1* updates
    waitOnFlip = False
    if start_drink1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        start_drink1.frameNStart = frameN  # exact frame index
        start_drink1.tStart = t  # local t and not account for scr refresh
        start_drink1.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(start_drink1, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'start_drink1.started')
        start_drink1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(start_drink1.clock.reset)  # t=0 on next screen flip
        # clear events on next screen flip
        win.callOnFlip(start_drink1.clearEvents, eventType='keyboard')
    if start_drink1.status == STARTED and not waitOnFlip:
        theseKeys = start_drink1.getKeys(keyList=['space'], waitRelease=False)
        _start_drink1_allKeys.extend(theseKeys)
        if len(_start_drink1_allKeys):
            # just the last key pressed
            start_drink1.keys = _start_drink1_allKeys[-1].name
            start_drink1.rt = _start_drink1_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        outlet.push_sample(markers['start_drink1'])
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in beforeStartComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "beforeStart" ---
for thisComponent in beforeStartComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if start_drink1.keys in ['', [], None]:  # No response was made
    start_drink1.keys = None
thisExp.addData('start_drink1.keys', start_drink1.keys)
if start_drink1.keys != None:  # we had a response
    thisExp.addData('start_drink1.rt', start_drink1.rt)
thisExp.nextEntry()
# the Routine "beforeStart" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# --- Prepare to start Routine "drink1" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
stop_drink1.keys = []
stop_drink1.rt = []
_stop_drink1_allKeys = []
# keep track of which components have finished
drink1Components = [drink1_5mins, stop_drink1]
for thisComponent in drink1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "drink1" ---
while continueRoutine:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *drink1_5mins* updates
    if drink1_5mins.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        drink1_5mins.frameNStart = frameN  # exact frame index
        drink1_5mins.tStart = t  # local t and not account for scr refresh
        drink1_5mins.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(drink1_5mins, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'drink1_5mins.started')
        drink1_5mins.setAutoDraw(True)
    if drink1_5mins.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > drink1_5mins.tStartRefresh + 300-frameTolerance:
            # keep track of stop time/frame for later
            drink1_5mins.tStop = t  # not accounting for scr refresh
            drink1_5mins.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink1_5mins.stopped')
            drink1_5mins.setAutoDraw(False)

    # *stop_drink1* updates
    waitOnFlip = False
    if stop_drink1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        stop_drink1.frameNStart = frameN  # exact frame index
        stop_drink1.tStart = t  # local t and not account for scr refresh
        stop_drink1.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(stop_drink1, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'stop_drink1.started')
        stop_drink1.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(stop_drink1.clock.reset)  # t=0 on next screen flip
        # clear events on next screen flip
        win.callOnFlip(stop_drink1.clearEvents, eventType='keyboard')
    if stop_drink1.status == STARTED and not waitOnFlip:
        theseKeys = stop_drink1.getKeys(keyList=['space'], waitRelease=False)
        _stop_drink1_allKeys.extend(theseKeys)
        if len(_stop_drink1_allKeys):
            # just the last key pressed
            stop_drink1.keys = _stop_drink1_allKeys[-1].name
            stop_drink1.rt = _stop_drink1_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        outlet.push_sample(markers['stop_drink1'])
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in drink1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "drink1" ---
for thisComponent in drink1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if stop_drink1.keys in ['', [], None]:  # No response was made
    stop_drink1.keys = None
thisExp.addData('stop_drink1.keys', stop_drink1.keys)
if stop_drink1.keys != None:  # we had a response
    thisExp.addData('stop_drink1.rt', stop_drink1.rt)
thisExp.nextEntry()
# the Routine "drink1" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# --- Prepare to start Routine "betweenTask" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
start_drink2.keys = []
start_drink2.rt = []
_start_drink2_allKeys = []
# keep track of which components have finished
betweenTaskComponents = [break_between, start_drink2]
for thisComponent in betweenTaskComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "betweenTask" ---
while continueRoutine:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *break_between* updates
    if break_between.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        break_between.frameNStart = frameN  # exact frame index
        break_between.tStart = t  # local t and not account for scr refresh
        break_between.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(break_between, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'break_between.started')
        break_between.setAutoDraw(True)

    # *start_drink2* updates
    waitOnFlip = False
    if start_drink2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        start_drink2.frameNStart = frameN  # exact frame index
        start_drink2.tStart = t  # local t and not account for scr refresh
        start_drink2.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(start_drink2, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'start_drink2.started')
        start_drink2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(start_drink2.clock.reset)  # t=0 on next screen flip
        # clear events on next screen flip
        win.callOnFlip(start_drink2.clearEvents, eventType='keyboard')
    if start_drink2.status == STARTED and not waitOnFlip:
        theseKeys = start_drink2.getKeys(keyList=['space'], waitRelease=False)
        _start_drink2_allKeys.extend(theseKeys)
        if len(_start_drink2_allKeys):
            # just the last key pressed
            start_drink2.keys = _start_drink2_allKeys[-1].name
            start_drink2.rt = _start_drink2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        outlet.push_sample(markers['start_drink2'])
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in betweenTaskComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "betweenTask" ---
for thisComponent in betweenTaskComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if start_drink2.keys in ['', [], None]:  # No response was made
    start_drink2.keys = None
thisExp.addData('start_drink2.keys', start_drink2.keys)
if start_drink2.keys != None:  # we had a response
    thisExp.addData('start_drink2.rt', start_drink2.rt)
thisExp.nextEntry()
# the Routine "betweenTask" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# --- Prepare to start Routine "drink2" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
stop_drink2.keys = []
stop_drink2.rt = []
_stop_drink2_allKeys = []
# keep track of which components have finished
drink2Components = [drink2_5mins, stop_drink2]
for thisComponent in drink2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "drink2" ---
while continueRoutine:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *drink2_5mins* updates
    if drink2_5mins.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        drink2_5mins.frameNStart = frameN  # exact frame index
        drink2_5mins.tStart = t  # local t and not account for scr refresh
        drink2_5mins.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(drink2_5mins, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'drink2_5mins.started')
        drink2_5mins.setAutoDraw(True)
    if drink2_5mins.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > drink2_5mins.tStartRefresh + 300-frameTolerance:
            # keep track of stop time/frame for later
            drink2_5mins.tStop = t  # not accounting for scr refresh
            drink2_5mins.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'drink2_5mins.stopped')
            drink2_5mins.setAutoDraw(False)

    # *stop_drink2* updates
    waitOnFlip = False
    if stop_drink2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        stop_drink2.frameNStart = frameN  # exact frame index
        stop_drink2.tStart = t  # local t and not account for scr refresh
        stop_drink2.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(stop_drink2, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'stop_drink2.started')
        stop_drink2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(stop_drink2.clock.reset)  # t=0 on next screen flip
        # clear events on next screen flip
        win.callOnFlip(stop_drink2.clearEvents, eventType='keyboard')
    if stop_drink2.status == STARTED and not waitOnFlip:
        theseKeys = stop_drink2.getKeys(keyList=['space'], waitRelease=False)
        _stop_drink2_allKeys.extend(theseKeys)
        if len(_stop_drink2_allKeys):
            # just the last key pressed
            stop_drink2.keys = _stop_drink2_allKeys[-1].name
            stop_drink2.rt = _stop_drink2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        outlet.push_sample(markers['stop_drink2'])
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in drink2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "drink2" ---
for thisComponent in drink2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if stop_drink2.keys in ['', [], None]:  # No response was made
    stop_drink2.keys = None
thisExp.addData('stop_drink2.keys', stop_drink2.keys)
if stop_drink2.keys != None:  # we had a response
    thisExp.addData('stop_drink2.rt', stop_drink2.rt)
thisExp.nextEntry()
# the Routine "drink2" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# --- Prepare to start Routine "afterTrial" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
rest_start.keys = []
rest_start.rt = []
_rest_start_allKeys = []
# keep track of which components have finished
afterTrialComponents = [before_rest, rest_start]
for thisComponent in afterTrialComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "afterTrial" ---
while continueRoutine:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *before_rest* updates
    if before_rest.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        before_rest.frameNStart = frameN  # exact frame index
        before_rest.tStart = t  # local t and not account for scr refresh
        before_rest.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(before_rest, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'before_rest.started')
        before_rest.setAutoDraw(True)

    # *rest_start* updates
    waitOnFlip = False
    if rest_start.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        rest_start.frameNStart = frameN  # exact frame index
        rest_start.tStart = t  # local t and not account for scr refresh
        rest_start.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(rest_start, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'rest_start.started')
        rest_start.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(rest_start.clock.reset)  # t=0 on next screen flip
        # clear events on next screen flip
        win.callOnFlip(rest_start.clearEvents, eventType='keyboard')
    if rest_start.status == STARTED and not waitOnFlip:
        theseKeys = rest_start.getKeys(keyList=['space'], waitRelease=False)
        _rest_start_allKeys.extend(theseKeys)
        if len(_rest_start_allKeys):
            # just the last key pressed
            rest_start.keys = _rest_start_allKeys[-1].name
            rest_start.rt = _rest_start_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        outlet.push_sample(markers['start_rest2'])
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in afterTrialComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "afterTrial" ---
for thisComponent in afterTrialComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if rest_start.keys in ['', [], None]:  # No response was made
    rest_start.keys = None
thisExp.addData('rest_start.keys', rest_start.keys)
if rest_start.keys != None:  # we had a response
    thisExp.addData('rest_start.rt', rest_start.rt)
thisExp.nextEntry()
# the Routine "afterTrial" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# --- Prepare to start Routine "rest_2" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
# keep track of which components have finished
rest_2Components = [dot]
for thisComponent in rest_2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "rest_2" ---
while continueRoutine and routineTimer.getTime() < 3600.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *dot* updates
    if dot.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        dot.frameNStart = frameN  # exact frame index
        dot.tStart = t  # local t and not account for scr refresh
        dot.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(dot, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'dot.started')
        dot.setAutoDraw(True)
    if dot.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > dot.tStartRefresh + 3600-frameTolerance:
            # keep track of stop time/frame for later
            dot.tStop = t  # not accounting for scr refresh
            dot.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'dot.stopped')
            dot.setAutoDraw(False)

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in rest_2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "rest_2" ---
for thisComponent in rest_2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-3600.000000)

# --- Prepare to start Routine "EndMessage" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
end_exp.keys = []
end_exp.rt = []
_end_exp_allKeys = []
# keep track of which components have finished
EndMessageComponents = [end_message, end_exp]
for thisComponent in EndMessageComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "EndMessage" ---
while continueRoutine:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

    # *end_message* updates
    if end_message.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        end_message.frameNStart = frameN  # exact frame index
        end_message.tStart = t  # local t and not account for scr refresh
        end_message.tStartRefresh = tThisFlipGlobal  # on global time
        # time at next scr refresh
        win.timeOnFlip(end_message, 'tStartRefresh')
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'end_message.started')
        end_message.setAutoDraw(True)

    # *end_exp* updates
    waitOnFlip = False
    if end_exp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        end_exp.frameNStart = frameN  # exact frame index
        end_exp.tStart = t  # local t and not account for scr refresh
        end_exp.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(end_exp, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'end_exp.started')
        end_exp.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(end_exp.clock.reset)  # t=0 on next screen flip
        # clear events on next screen flip
        win.callOnFlip(end_exp.clearEvents, eventType='keyboard')
    if end_exp.status == STARTED and not waitOnFlip:
        theseKeys = end_exp.getKeys(keyList=['space'], waitRelease=False)
        _end_exp_allKeys.extend(theseKeys)
        if len(_end_exp_allKeys):
            # just the last key pressed
            end_exp.keys = _end_exp_allKeys[-1].name
            end_exp.rt = _end_exp_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False

    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        outlet.push_sample(markers['end_exp'])
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in EndMessageComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished

    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "EndMessage" ---
for thisComponent in EndMessageComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if end_exp.keys in ['', [], None]:  # No response was made
    end_exp.keys = None
thisExp.addData('end_exp.keys', end_exp.keys)
if end_exp.keys != None:  # we had a response
    thisExp.addData('end_exp.rt', end_exp.rt)
thisExp.nextEntry()
# the Routine "EndMessage" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# --- End experiment ---
# Flip one final time so any remaining win.callOnFlip()
# and win.timeOnFlip() tasks get executed before quitting
win.flip()

# these shouldn't be strictly necessary (should auto-save)
thisExp.saveAsWideText(filename+'.csv', delim='auto')
thisExp.saveAsPickle(filename)
logging.flush()
# make sure everything is closed down
if eyetracker:
    eyetracker.setConnectionState(False)
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()
